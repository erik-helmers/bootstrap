#+title: Bootstrap
#+author: Erik Helmers

#+startup: latexpreview fold

#+latex_header: \usepackage{proof}
#+latex_header: \usepackage{mathpartir}
#+latex_header: \usepackage{amsmath,amssymb,amsthm,textcomp}
#+latex_header: \usepackage{listofitems}
#+latex_header: \usepackage{bssetup}


#+name: bssetup
#+begin_src latex :tangle bssetup.sty :exports none


% Construit une substitution sur une liste #1
% définie avec \readlist et pour valeur par défaut #2
% Substitution
\newcommand{\varlist}[3]{% 1 = symbol list, 2 = default command, 3 = index
  \ifnum #3>\listlen{#1}[]%
     #2{#3}%
  \else #1[#3]
  \fi
}

% Term symbols

% Expression term identifiers
\readlist*\tesyms{e,e',e''}
\newcommand{\tedflt}[1]{e_{#1}}
\newcommand{\te}[1][1]{\varlist{\tesyms}{\tedflt}{#1}}

% Term type identifiers
\readlist*\ttysyms{\sigma, \sigma', \sigma''}
\newcommand{\ttydflt}[1]{\sigma_{#1}}
\newcommand{\tty}[1][1]{\varlist{\ttysyms}{\ttydflt}{#1}}

% Term kind identifiers
\readlist*\tksyms{\kappa, \kappa', \kappa''}
\newcommand{\tkdflt}[1]{\kappa_{#1}}
\newcommand{\tk}[1][1]{\varlist{\tksyms}{\tkdflt}{#1}}

% Term variables (used in binders)
\readlist*\tvsyms{x, y, z}
\newcommand{\tvdflt}[1]{x_{#1}}
\newcommand{\tv}[1][1]{\varlist{\tvsyms}{\tvdflt}{#1}}


% Lambda
\newcommand{\tlam}[2]{\lambda #1 \rightarrow #2}
% Tuple
\newcommand{\ttup}[2]{(#1,#2)}
% Fst
\newcommand{\tfst}[1]{\text{fst}\ #1}
% Snd
\newcommand{\tsnd}[1]{\text{snd}\ #1}
% Pi
\newcommand{\tpi}[3]{\Pi(#1:#2).#3}
% Sigma
\newcommand{\tsig}[3]{\Sigma(#1:#2).#3}
% Type of types
\newcommand{\tstar}{\star}


% Value symbols

% Value identifiers
\readlist*\vesyms{\nu,\nu',\nu''}
\newcommand{\vedflt}[1]{\nu_{#1}}
\newcommand{\ve}[1][1]{\varlist{\vesyms}{\vedflt}{#1}}

% Type identifiers
\readlist*\vtysyms{\tau, \tau', \tau''}
\newcommand{\vtydflt}[1]{\tau_{#1}}
\newcommand{\vty}[1][1]{\varlist{\vtysyms}{\vtydflt}{#1}}

% Neutral
\readlist*\vnsyms{n, n', n''}
\newcommand{\vndflt}[1]{n_{#1}}
\newcommand{\vn}[1][1]{\varlist{\vnsyms}{\vndflt}{#1}}

% Variables
\readlist*\vvsyms{x, y, z}
\newcommand{\vvdflt}[1]{x_{#1}}
\newcommand{\vv}[1][1]{\varlist{\vvsyms}{\vvdflt}{#1}}

% Lambda
\newcommand{\vlam}[2]{\lambda #1 \rightarrow #2}
% Tuple
\newcommand{\vtup}[2]{(#1,#2)}
% Pi
\newcommand{\vpi}[3]{\Pi(#1:#2).#3}
% Sigma
\newcommand{\vsig}[3]{\Sigma(#1:#2).#3}
% Type of types
\newcommand{\vstar}{\star}

% Symbols

\newcommand{\evalsto}{\Downarrow}
\newcommand{\tycheck}{:_{\downarrow}}
\newcommand{\tyinfer}{:_{\uparrow}}

\newcommand{\ctx}{\Gamma}
\newcommand{\ctxmap}{\vdash}
\newcommand{\ctxEmpty}{\Gamma}
\newcommand{\ctxValid}[1]{\text{valid}(#1)}


#+end_src

* Théorie

** Syntaxe

\[\begin{array}{lcll}
\te, \tty, \tk &::=&\te: \tty                  &\text{annotated term} \\
         &|& \tv                       &\text{variable} \\
         &|& \tlam{x}{\te}           &\text{lambda} \\
         &|& \te\ \te[2]               &\text{application} \\
         &|& \tpi{x}{\tty}{\tty[2]}  &\text{pi type} \\
         &|& (\te, \te[2])             &\text{tuple} \\
         &|& \tfst{\te}              &\text{fst} \\
         &|& \tsnd{\te}              &\text{snd} \\
         &|& \tsig{\tv}{\tty}{\tty[2]} &\text{sigma type} \\
         &|&  \tstar                      &\text{type of types} \\
\end{array}
 \]

where $\te$, $\tty$, $\tk$ represent general expressions, types and kinds respectively.


** Contexte

\[\begin{array}{lcll}
\ctx &::=&\epsilon                  &\text{empty context}     \\
         &|& \ctx, \tv:\vty   &\text{adding a variable} \\
\end{array}
\]

\begin{mathpar}
\inferrule*{  }{ \ctxValid{\epsilon} }
\inferrule*
    { \ctxValid{\ctx} \\ \ctx \ctxmap \vty \tycheck \vstar }
    { \ctxValid{\ctx, \tv : \vty} }
\end{mathpar}

** Evaluation


\[\begin{array}{lcll}
\ve, \vty &::=& \vn                       &\text{neutral term} \\
         & | & \vlam {\vv} {\ve}         &\text{lambda} \\
         & | & \vtup {\ve} {\ve[2]}      &\text{tuple} \\
         & | & \vstar                    &\text{type of types} \\
         & | & \vpi {\tv} {\vty} {\vty[2]} &\text{dependent function space} \\
         & | & \vsig {\tv}{\vty}{\vty[2]}  &\text{dependent pair space } \\
\end{array}
\]

\begin{mathpar}


\inferrule*[right=(Star)] {\\} { \tstar \evalsto \vstar} \and

\inferrule*[right=(Var)]{\\}{ \tv \evalsto \vv} \and

\inferrule*[right=(Ann)]
  {\te \evalsto \ve}
  {\te: \tty \evalsto \ve}
\and

\inferrule*[right=(Lam)]
    {\te\evalsto \ve }
    { \tlam{\tv}{\te} \evalsto \vlam{x}{\ve}}
\and
\inferrule*[right=(Tuple)]
    {\te\evalsto \ve \\ \te[2] \evalsto \ve[2] }
    { (\te, \te[2]) \evalsto (\ve, \ve[2])}
\and

\inferrule*[right=(App)]
  {\te \evalsto \vlam{\vv}{\ve} \\ \ve[1][ x \mapsto \te[2]] \evalsto \ve[2]}
  { \te\ \te[2] \evalsto \ve[2]}
\and
\inferrule*[right=(NApp)]
  {\te \evalsto \vn \\ \te[2] \evalsto \ve[2]}
  {\te \ \te[2] \evalsto \vn\ \ve[2]}
\and

\inferrule*[right=(Fst)]
  {\te  \evalsto (\ve ,\ve[2])}
  { \tfst{\te} \evalsto \ve}
\and

\inferrule*[right=(Snd)]
  {\te \evalsto (\ve,\ve[2])}
  { \tsnd{\te} \evalsto \ve[2]}
\and

\inferrule*[right=(Pi)]
  {\tty \evalsto \vty \\ \tty[2] \evalsto \vty[2]}
  {\tpi{\tv}{\tty}{\tty[2]} \evalsto \vpi{\vv}{\vty}{\vty[2]}}
\and

\inferrule*[right=(Sigma)]
  {\tty \evalsto \vty \\ \tty[2] \evalsto \vty[2]}
  {\tsig{\tv}{\tty}{\tty[2]} \evalsto \vsig{\vv}{\vty}{\vty[2]}}
\and


\end{mathpar}


** Typing

In the following, \(\te\tyinfer \vty\) is an expression with inferrable type $\vty$ while \(e \tycheck \vty\) is checkable.

\begin{mathpar}
\centering

\inferrule*[right=(Chk)] { \ctx \vdash \tv \tyinfer \vty }{ \ctx \vdash \tv \tycheck \vty }
\and

\inferrule*[right=(Ann)]
  {\ctx \vdash \tty \tycheck * \\ \tty \evalsto \vty \\
   \ctx \vdash\te\tycheck \vty}
  { \ctx \vdash (\te:\tty) \tyinfer \vty }
\and


\inferrule*[right=(Star)]{ }{ \ctx \vdash \tstar \tyinfer \vstar }
\and


\inferrule*[right=(Var)] { \ctx(\tv) = \vty }{ \ctx \vdash \tv \tyinfer \vty }
\and

\inferrule*[right=(Lam)]
  { \ctx,\tv : \vty \vdash\te\tycheck \vty[2] }
  { \ctx \vdash  \vlam{\tv}{\te} \tycheck \vpi{\tv}{\vty}{} \vty[2]}
\and

\inferrule*[right=(Tuple)]
  { \ctx \vdash\te\tycheck \vty \\  \ctx \vdash \te[2] \tycheck \vty[2]}
  { \ctx \vdash  (\te,\te[2]) \tycheck \vsig (\tv : \vty) . \vty[2]}
\and

\inferrule*[right=(App)]
  { \ctx \vdash\te\tyinfer  \vpi{x}{\vty}{\vty[2]}  \\  \ctx \vdash \te[2] \tycheck \vty \\ \vty[2][x \mapsto \te[2]] \evalsto \vty[3] }
  { \ctx \vdash \te\ \te[2] \tyinfer \vty[3]}
\and

\inferrule*[right=(Fst)]
  { \ctx \vdash\te\tyinfer \vsig{x}{\vty}{\vty[2]}}
  { \ctx \vdash \tfst{\te} \tyinfer \vty}
\and

\inferrule*[right=(Snd)]
  { \ctx \vdash\te\tyinfer \vsig{x}{\vty}{\vty[2]} \\ \vty[2][x \mapsto \text{fst}\ e] \evalsto \vty[3] }
  { \ctx \vdash \tsnd{\te} \tyinfer \vty[3]}
\and
\inferrule*[right=(Pi)]
   { \ctx \vdash \tty \tycheck \vstar \\ \tty \evalsto \vty \\ \ctx,\tv:\vty \vdash \tty[2] \tycheck \vstar }
   { \ctx \vdash \tpi{\tv}{\tty}{\tty[2]} \tyinfer \vstar }
\label{ty:pi}
\and

\inferrule*[right=(Sigma)]
   { \ctx \vdash \tty \tycheck \vstar \\ \tty \evalsto \vty \\ \ctx,\tv:\vty \vdash \tty[2] \tycheck \vstar }
   { \ctx \vdash \tsig{\tv}{\tty}{\tty[2]} \tyinfer \vstar }
\and
\end{mathpar}

Une reformulation équivalentes des règles $\textsc{(Pi)}$ et $\textsc{(Sigma)}$, plus adaptée pour l'implémentation :

\begin{mathpar}
\inferrule*[right=(Pi)]
   { \ctx \vdash \tty \tycheck \vstar \\ \tty \evalsto \vty \\ \ctx \vdash \tty[2] \tycheck \vpi{\tv}{\vty}{\vstar} }
   { \ctx \vdash \vpi{\tv }{ \tty}{\tty[2]} \tyinfer \vstar }
\and

\inferrule*[right=(Sigma)]
   { \ctx \vdash \tty \tycheck \vstar \\ \tty \evalsto \vty \\ \ctx \vdash \tty[2] \tycheck \vpi{\tv}{\vty}{\vstar} }
   { \ctx \vdash \vsig{\tv}{\tty}{\tty[2]} \tyinfer \vstar }
\and
\end{mathpar}
