#+title: Bootstrap
#+author: Erik Helmers


#+latex_header_extra: \usepackage{proof,mathpartir}
#+latex_header_extra: \usepackage{amsmath,amssymb,amsthm,textcomp}


* NO Design et implémentation d'une syntaxe support


L'objectif du sujet est de développer un certain moteur de typage. Pour commencer, on va donc créer un petit language interpreté qui servira de base pour pratiquer nos expérimentations.

Pour rendre agréable le travail, on a ajouté de la syntaxe (=let id = ... in ...=, =let cons x y = x=, etc..) en veillant à ne pas ajouter de nouveau termes (par exemple les assignations sont juste des applications de fonctions).

#+begin_quote
letter   ::= A...Z | a...z

number   ::= 0...9

ident    ::= (letter|number|_) {letter|0...9|_|'}

#+end_quote

* Théorie

** Syntaxe


#+begin_src latex

\begin{array}{lcll}
e, \rho, \kappa &::=& e : \rho         &\text{annotated term} \\
         &|& x              &\text{variable} \\
         &|& \lambda x \rightarrow e        &\text{lambda} \\
         &|& e\ e'          &\text{application} \\
         &|& \Pi (x : \rho).\rho'   &\text{pi type} \\
         &|& (e, e')        &\text{tuple} \\
         &|& \text{fst}\ \nu  &\text{fst} \\
         &|& \text{snd}\ \nu  &\text{snd} \\
         &|& \Sigma (x : \rho).\rho'   &\text{sigma type} \\
         &|&  *             &\text{type of types} \\
\end{array}

where $e$, $\rho$, $\kappa$ represent expressions, types and kinds respectively.
#+end_src


** Evaluation

#+begin_src latex


\begin{array}{lcll}
\nu, \tau    &::=& n           &\text{neutral term} \\
         &|& \lambda x \rightarrow \nu      &\text{lambda} \\
         &|& (\nu, \nu')      &\text{tuple} \\
         &|&  *           &\text{type of types} \\
         &|& \Pi (x : \tau).\tau' &\text{dependent function space} \\
         &|& \Sigma (x : \tau).\tau' &\text{dependent pair space (?)} \\
\end{array}

\begin{mathpar}


\inferrule*[right=(Star)] {\quad} { * \Downarrow *} \and

\inferrule*[right=(Var)]{\quad}{ x \Downarrow x} \and

\inferrule*[right=(Ann)]
  { e \Downarrow \nu}
  { e : \rho \Downarrow \nu}
\and

\inferrule*[right=(Lam)]
    { e \Downarrow \nu }
    { \lambda x \rightarrow e \Downarrow \lambda x \rightarrow \nu}
\and
\inferrule*[right=(Tuple)]
    { e \Downarrow \nu \quad e' \Downarrow \nu' }
    { (e, e') \Downarrow (\nu, \nu')}
\and

\inferrule*[right=(App)]
  {e \Downarrow \lambda x \rightarrow \nu \quad \nu[ x \mapsto e'] \Downarrow \nu'}
  { e\ e' \Downarrow \nu'}
\and
\inferrule*[right=(NApp)]
  {e \Downarrow n \quad e' \Downarrow \nu'}
  { e\ e' \Downarrow n\ \nu'}
\and

\inferrule*[right=(Fst)]
  {e \Downarrow (\nu,\nu')}
  { \text{fst}\ e \Downarrow \nu}
\and

\inferrule*[right=(Snd)]
  {e \Downarrow (\nu,\nu')}
  { \text{snd}\ e \Downarrow \nu'}
\and

\inferrule*[right=(Pi)]
  {\rho \Downarrow \tau \quad \rho' \Downarrow \tau'}
  {\Pi (x : \rho).\rho' \Downarrow \Pi (x : \tau).\tau'}
\and

\inferrule*[right=(Sigma)]
  {\rho \Downarrow \tau \quad \rho' \Downarrow \tau'}
  {\Sigma (x : \rho).\rho' \Downarrow \Sigma (x : \tau).\tau'}
\and


\end{mathpar}

#+end_src

** Typing
#+begin_src latex

In the following, $e :_{\uparrow} \tau}$ is an expression with inferrable type $\tau$ while $e :_{\downarrow} \tau}$ is checkable.

\begin{mathpar}
\centering

\inferrule*[right=(Chk)] { \Gamma \vdash x :_{\uparrow} \tau }{ \Gamma \vdash x :_{\downarrow} \tau }
\and

\inferrule*[right=(Ann)]
  {\Gamma \vdash \rho :_{\downarrow} * \quad \rho \Downarrow \tau \\
   \Gamma \vdash e :_{\downarrow} \tau}
  { \Gamma \vdash (e:\rho) :_{\uparrow} \tau }
\and


\inferrule*[right=(Star)]{\quad}{ \Gamma \vdash * :_{\uparrow} * }
\and


\inferrule*[right=(Var)] { \Gamma(x) = \tau }{ \Gamma \vdash x :_{\uparrow} \tau }
\and

\inferrule*[right=(Lam)]
  { \Gamma,x : \tau \vdash e :_{\downarrow} \tau' }
  { \Gamma \vdash  \lambda x \rightarrow e :_{\downarrow} \Pi (x : \tau) . \tau'}
\and

\inferrule*[right=(Tuple)]
  { \Gamma \vdash e :_{\downarrow} \tau \quad  \Gamma \vdash e' :_{\downarrow} \tau'}
  { \Gamma \vdash  (e,e') :_{\downarrow} \Sigma (x : \tau) . \tau'}
\and

\inferrule*[right=(App)]
  { \Gamma \vdash e :_{\uparrow}  \Pi (x:\tau).\tau'  \quad  \Gamma \vdash e' :_{\downarrow} \tau \quad \tau'[x \mapsto e'] \Downarrow \tau'' }
  { \Gamma \vdash e\ e' :_{\uparrow} \tau''}
\and

\inferrule*[right=(Fst)]
  { \Gamma \vdash e :_{\uparrow} \Sigma(x:\tau).\tau'}
  { \Gamma \vdash \text{fst}\ e :_{\uparrow} \tau}
\and

\inferrule*[right=(Snd)]
  { \Gamma \vdash e :_{\uparrow} \Sigma(x:\tau).\tau' \quad \tau'[x \mapsto \text{fst}\ e] \Downarrow \tau'' }
  { \Gamma \vdash \text{snd}\ e:_{\uparrow} \tau''}
\and
\inferrule*[right=(Pi)]
   { \Gamma \vdash \rho :_{\downarrow} * \quad \rho \Downarrow \tau \\ \Gamma,x:\tau \vdash \rho' :_{\downarrow} * }
   { \Gamma \vdash \Pi (x : \rho).\rho' :_{\uparrow} * }
\and

\inferrule*[right=(Sigma)]
   { \Gamma \vdash \rho :_{\downarrow} * \quad \rho \Downarrow \tau \\ \Gamma,x:\tau \vdash \rho' :_{\downarrow} * }
   { \Gamma \vdash \Sigma (x : \rho).\rho' :_{\uparrow} * }
\and
\end{mathpar}

#+end_src



